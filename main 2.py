import config
import logging
from aiogram import Bot, Dispatcher, types
from aiogram.contrib.middlewares.logging import LoggingMiddleware
from aiogram.types import ParseMode

# Инициализация бота и диспетчера
bot = Bot(token=config.BOT_TOKEN)
dp = Dispatcher(bot)
logging.basicConfig(level=logging.INFO)

# Создание словаря для хранения состояний пользователей
состояния_пользователей = {}


@dp.message_handler(commands=['start'])
async def start(message: types.Message):
    user_id = message.from_user.id

    # Проверяем, есть ли у пользователя уже существующее состояние или создаем новое
    if user_id not in состояния_пользователей:
        состояния_пользователей[user_id] = {}
    состояние_пользователя = состояния_пользователей[user_id]

    # Проверяем текущее состояние пользователя и действуем соответственно
    if 'ФИО' not in состояние_пользователя:
        await message.answer(
            "Добро пожаловать в официальный чат бот компании DentRoom , для записи пожалуйста, укажите вашу фамилию и инициалы:")
        состояние_пользователя['текущее_состояние'] = 'ФИО'
    elif 'телефон' not in состояние_пользователя:
        await message.answer("Отлично! Теперь укажите ваш номер телефона:")
        состояние_пользователя['текущее_состояние'] = 'телефон'
    elif 'Дата рождения' not in состояние_пользователя:
        await message.answer("Спасибо! Укажите вашу дату рождения:")
        состояние_пользователя['текущее_состояние'] = 'дата рождения'
    elif 'желаемая_дата_и_время_записи' not in состояние_пользователя:
        await message.answer("Спасибо! В конце, укажите желаемую дату и время записи:")
        состояние_пользователя['текущее_состояние'] = 'желаемая_дата_и_время_записи'
    else:
        await message.answer("Вы завершили процесс записи. Спасибо! с вами в ближайшее время свяжутся")


# Обработка сообщений пользователя на основе текущего состояния
@dp.message_handler(lambda message: message.text, state="*")
async def process_message(message: types.Message):
    user_id = message.from_user.id
    состояние_пользователя = состояния_пользователей.get(user_id, {})

    # Проверяем текущее состояние пользователя и действуем соответственно
    if 'текущее_состояние' in состояние_пользователя:
        текущее_состояние = состояние_пользователя['текущее_состояние']
        if текущее_состояние == 'ФИО':
            состояние_пользователя['ФИО'] = message.text
            await message.answer("Отлично! Теперь укажите ваш номер телефона:")
            состояние_пользователя['текущее_состояние'] = 'телефон'
        elif текущее_состояние == 'телефон':
            состояние_пользователя['телефон'] = message.text
            await message.answer("Спасибо! Укажите вашу дату рождения:")
            состояние_пользователя['текущее_состояние'] = 'дата рождения'
        elif текущее_состояние == 'дата рождения':
            состояние_пользователя['дата рождения'] = message.text
            await message.answer("Спасибо! В конце, укажите желаемую дату и время записи:")
            состояние_пользователя['текущее_состояние'] = 'желаемая_дата_и_время_записи'
        elif текущее_состояние == 'желаемая_дата_и_время_записи':
            состояние_пользователя['желаемая_дата_и_время_записи'] = message.text
            # Обрабатываем данные пользователя и очищаем состояние
            текст_пользователя = f"ФИО: {состояние_пользователя['ФИО']}\nТелефон: {состояние_пользователя['телефон']}\nДата рождения: {состояние_пользователя['дата рождения']}\nЖелаемая дата и время записи: {состояние_пользователя['желаемая_дата_и_время_записи']}"
            await bot.send_message(chat_id='', text=текст_пользователя, parse_mode=ParseMode.MARKDOWN)
            del состояния_пользователей[user_id]
            await message.answer("Вы завершили процесс записи. Спасибо! с вами в ближайшее время свяжутся.")
    else:
        await message.answer("Пожалуйста, начните процесс, отправив /start.")


if __name__ == '__main__':
    from aiogram import executor

    dp.middleware.setup(LoggingMiddleware())

    executor.start_polling(dp, skip_updates=True)
